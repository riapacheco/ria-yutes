{"version":3,"file":"index.production.js","sources":["../../src/utils/flatten.ts","../../src/utils/generateAutocompleteId.ts","../../src/utils/getItemsCount.ts","../../src/utils/getNextSelectedItemId.ts","../../src/utils/noop.ts","../../src/utils/getSelectedItem.ts","../../src/utils/isOrContainsNode.ts","../../src/getDefaultProps.ts","../../src/utils/getNormalizedSources.ts","../../src/onInput.ts","../../src/getPropGetters.ts","../../src/onKeyDown.ts","../../src/getCompletion.ts","../../src/stateReducer.ts","../../src/createAutocomplete.ts","../../src/createStore.ts","../../src/getAutocompleteSetters.ts","../../src/version.ts"],"sourcesContent":["export function flatten<TType>(values: Array<TType | TType[]>): TType[] {\n  return values.reduce<TType[]>((a, b) => {\n    return a.concat(b);\n  }, []);\n}\n","let autocompleteId = 0;\n\nexport function generateAutocompleteId() {\n  return `autocomplete-${autocompleteId++}`;\n}\n","import { AutocompleteState } from '../types';\n\nexport function getItemsCount(state: AutocompleteState<any>) {\n  if (state.collections.length === 0) {\n    return 0;\n  }\n\n  return state.collections.reduce<number>(\n    (sum, collection) => sum + collection.items.length,\n    0\n  );\n}\n","/**\n * Returns the next selected item ID from the current state.\n *\n * We allow circular keyboard navigation from the base index.\n * The base index can either be `null` (nothing is highlighted) or `0`\n * (the first item is highlighted).\n * The base index is allowed to get assigned `null` only if\n * `props.defaultSelectedItemId` is `null`. This pattern allows to \"stop\"\n * by the actual query before navigating to other suggestions as seen on\n * Google or Amazon.\n *\n * @param moveAmount The offset to increment (or decrement) the last index\n * @param baseIndex The current index to compute the next index from\n * @param itemCount The number of items\n * @param defaultSelectedItemId The default selected index to fallback to\n */\nexport function getNextSelectedItemId(\n  moveAmount: number,\n  baseIndex: number | null,\n  itemCount: number,\n  defaultSelectedItemId: number | null\n): number | null {\n  if (\n    moveAmount < 0 &&\n    (baseIndex === null || (defaultSelectedItemId !== null && baseIndex === 0))\n  ) {\n    return itemCount + moveAmount;\n  }\n\n  const numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;\n\n  if (numericIndex <= -1 || numericIndex >= itemCount) {\n    return defaultSelectedItemId === null ? null : 0;\n  }\n\n  return numericIndex;\n}\n","export const noop = () => {};\n","import { AutocompleteCollection, AutocompleteState, BaseItem } from '../types';\n\n// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromSelectedItemId<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n): AutocompleteCollection<TItem> | undefined {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  const accumulatedCollectionsCount = state.collections\n    .map((collections) => collections.items.length)\n    .reduce<number[]>((acc, collectionsCount, index) => {\n      const previousValue = acc[index - 1] || 0;\n      const nextValue = previousValue + collectionsCount;\n\n      acc.push(nextValue);\n\n      return acc;\n    }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  const collectionIndex = accumulatedCollectionsCount.reduce((acc, current) => {\n    if (current <= state.selectedItemId!) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n\n  return state.collections[collectionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      â†‘\n *         (absolute: 3, relative: 1)\n */\nfunction getRelativeSelectedItemId<TItem extends BaseItem>({\n  state,\n  collection,\n}: {\n  state: AutocompleteState<TItem>;\n  collection: AutocompleteCollection<TItem>;\n}): number {\n  let isOffsetFound = false;\n  let counter = 0;\n  let previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    const currentCollection = state.collections[counter];\n\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentCollection.items.length;\n\n    counter++;\n  }\n\n  return state.selectedItemId! - previousItemsOffset;\n}\n\nexport function getSelectedItem<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n) {\n  const collection = getCollectionFromSelectedItemId(state);\n\n  if (!collection) {\n    return null;\n  }\n\n  const item =\n    collection.items[getRelativeSelectedItemId({ state, collection })];\n  const source = collection.source;\n  const itemInputValue = source.getItemInputValue({ item, state });\n  const itemUrl = source.getItemUrl({ item, state });\n\n  return {\n    item,\n    itemInputValue,\n    itemUrl,\n    source,\n  };\n}\n","export function isOrContainsNode(parent: Node, child: Node) {\n  return parent === child || parent.contains(child);\n}\n","import {\n  AutocompleteOptions,\n  BaseItem,\n  InternalAutocompleteOptions,\n  AutocompleteSubscribers,\n} from './types';\nimport {\n  generateAutocompleteId,\n  getItemsCount,\n  getNormalizedSources,\n  flatten,\n} from './utils';\n\nexport function getDefaultProps<TItem extends BaseItem>(\n  props: AutocompleteOptions<TItem>,\n  pluginSubscribers: AutocompleteSubscribers<TItem>\n): InternalAutocompleteOptions<TItem> {\n  const environment: InternalAutocompleteOptions<TItem>['environment'] = (typeof window !==\n  'undefined'\n    ? window\n    : {}) as typeof window;\n  const plugins = props.plugins || [];\n\n  return {\n    debug: false,\n    openOnFocus: false,\n    placeholder: '',\n    autoFocus: false,\n    defaultSelectedItemId: null,\n    stallThreshold: 300,\n    environment,\n    shouldPanelShow: ({ state }) => getItemsCount(state) > 0,\n    ...props,\n    // Since `generateAutocompleteId` triggers a side effect (it increments\n    // and internal counter), we don't want to execute it if unnecessary.\n    id: props.id ?? generateAutocompleteId(),\n    plugins,\n    // The following props need to be deeply defaulted.\n    initialState: {\n      selectedItemId: null,\n      query: '',\n      completion: null,\n      collections: [],\n      isOpen: false,\n      status: 'idle',\n      context: {},\n      ...props.initialState,\n    },\n    onStateChange(params) {\n      props.onStateChange?.(params);\n      plugins.forEach((x) => x.onStateChange?.(params));\n    },\n    onSubmit(params) {\n      props.onSubmit?.(params);\n      plugins.forEach((x) => x.onSubmit?.(params));\n    },\n    onReset(params) {\n      props.onReset?.(params);\n      plugins.forEach((x) => x.onReset?.(params));\n    },\n    getSources(params) {\n      return Promise.all(\n        [...plugins.map((plugin) => plugin.getSources), props.getSources]\n          .filter(Boolean)\n          .map((getSources) => getNormalizedSources(getSources!, params))\n      )\n        .then((nested) => flatten(nested))\n        .then((sources) =>\n          sources.map((source) => ({\n            ...source,\n            onSelect(params) {\n              source.onSelect(params);\n              pluginSubscribers.forEach((x) => x.onSelect?.(params));\n            },\n            onHighlight(params) {\n              source.onHighlight(params);\n              pluginSubscribers.forEach((x) => x.onHighlight?.(params));\n            },\n          }))\n        );\n    },\n    navigator: {\n      navigate({ itemUrl }) {\n        environment.location.assign(itemUrl);\n      },\n      navigateNewTab({ itemUrl }) {\n        const windowReference = environment.open(itemUrl, '_blank', 'noopener');\n        windowReference?.focus();\n      },\n      navigateNewWindow({ itemUrl }) {\n        environment.open(itemUrl, '_blank', 'noopener');\n      },\n      ...props.navigator,\n    },\n  };\n}\n","import { invariant } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteSource,\n  BaseItem,\n  GetSources,\n  GetSourcesParams,\n  InternalAutocompleteSource,\n  InternalGetSources,\n} from '../types';\n\nimport { noop } from './noop';\n\nexport function getNormalizedSources<TItem extends BaseItem>(\n  getSources: GetSources<TItem>,\n  params: GetSourcesParams<TItem>\n): ReturnType<InternalGetSources<TItem>> {\n  return Promise.resolve(getSources(params)).then((sources) => {\n    invariant(\n      Array.isArray(sources),\n      `The \\`getSources\\` function must return an array of sources but returned type ${JSON.stringify(\n        typeof sources\n      )}:\\n\\n${JSON.stringify(sources, null, 2)}`\n    );\n\n    return Promise.all(\n      sources\n        // We allow `undefined` and `false` sources to allow users to use\n        // `Boolean(query) && source` (=> `false`).\n        // We need to remove these values at this point.\n        .filter((maybeSource: any): maybeSource is AutocompleteSource<TItem> =>\n          Boolean(maybeSource)\n        )\n        .map((source) => {\n          const normalizedSource: InternalAutocompleteSource<TItem> = {\n            getItemInputValue({ state }) {\n              return state.query;\n            },\n            getItemUrl() {\n              return undefined;\n            },\n            onSelect({ setIsOpen }) {\n              setIsOpen(false);\n            },\n            onHighlight: noop,\n            ...source,\n          };\n\n          return Promise.resolve(normalizedSource);\n        })\n    );\n  });\n}\n","import { invariant } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteScopeApi,\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getSelectedItem } from './utils';\n\nlet lastStalledId: number | null = null;\n\ninterface OnInputParams<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: any;\n  /**\n   * The next partial state to apply after the function is called.\n   *\n   * This is useful when we call `onInput` in a different scenario than an\n   * actual input. For example, we use `onInput` when we click on an item,\n   * but we want to close the panel in that case.\n   */\n  nextState?: Partial<AutocompleteState<TItem>>;\n  props: InternalAutocompleteOptions<TItem>;\n  query: string;\n  store: AutocompleteStore<TItem>;\n}\n\nexport function onInput<TItem extends BaseItem>({\n  event,\n  nextState = {},\n  props,\n  query,\n  refresh,\n  store,\n  ...setters\n}: OnInputParams<TItem>): Promise<void> {\n  if (props.onInput) {\n    return Promise.resolve(\n      props.onInput({\n        query,\n        refresh,\n        state: store.getState(),\n        ...setters,\n      })\n    );\n  }\n\n  if (lastStalledId) {\n    props.environment.clearTimeout(lastStalledId);\n  }\n\n  const {\n    setCollections,\n    setIsOpen,\n    setQuery,\n    setSelectedItemId,\n    setStatus,\n  } = setters;\n\n  setQuery(query);\n  setSelectedItemId(props.defaultSelectedItemId);\n\n  if (query.length === 0 && props.openOnFocus === false) {\n    setStatus('idle');\n    setCollections(\n      store.getState().collections.map((collection) => ({\n        ...collection,\n        items: [],\n      }))\n    );\n    setIsOpen(\n      nextState.isOpen ?? props.shouldPanelShow({ state: store.getState() })\n    );\n\n    return Promise.resolve();\n  }\n\n  setStatus('loading');\n\n  lastStalledId = props.environment.setTimeout(() => {\n    setStatus('stalled');\n  }, props.stallThreshold);\n\n  return props\n    .getSources({\n      query,\n      refresh,\n      state: store.getState(),\n      ...setters,\n    })\n    .then((sources) => {\n      setStatus('loading');\n\n      // @TODO: convert `Promise.all` to fetching strategy.\n      return Promise.all(\n        sources.map((source) => {\n          return Promise.resolve(\n            source.getItems({\n              query,\n              refresh,\n              state: store.getState(),\n              ...setters,\n            })\n          ).then((items) => {\n            invariant(\n              Array.isArray(items),\n              `The \\`getItems\\` function must return an array of items but returned type ${JSON.stringify(\n                typeof items\n              )}:\\n\\n${JSON.stringify(items, null, 2)}`\n            );\n\n            return { source, items };\n          });\n        })\n      )\n        .then((collections) => {\n          setStatus('idle');\n          setCollections(collections as any);\n          setIsOpen(\n            nextState.isOpen ??\n              ((query.length === 0 && props.openOnFocus) ||\n                props.shouldPanelShow({ state: store.getState() }))\n          );\n\n          const highlightedItem = getSelectedItem(store.getState());\n\n          if (store.getState().selectedItemId !== null && highlightedItem) {\n            const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n            source.onHighlight({\n              event,\n              item,\n              itemInputValue,\n              itemUrl,\n              refresh,\n              source,\n              state: store.getState(),\n              ...setters,\n            });\n          }\n        })\n        .catch((error) => {\n          setStatus('error');\n\n          throw error;\n        })\n        .finally(() => {\n          if (lastStalledId) {\n            props.environment.clearTimeout(lastStalledId);\n          }\n        });\n    });\n}\n","import { onInput } from './onInput';\nimport { onKeyDown } from './onKeyDown';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  GetEnvironmentProps,\n  GetFormProps,\n  GetInputProps,\n  GetItemProps,\n  GetLabelProps,\n  GetListProps,\n  GetPanelProps,\n  GetRootProps,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getSelectedItem, isOrContainsNode } from './utils';\n\ninterface GetPropGettersOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  store: AutocompleteStore<TItem>;\n  props: InternalAutocompleteOptions<TItem>;\n}\n\nexport function getPropGetters<\n  TItem extends BaseItem,\n  TEvent,\n  TMouseEvent,\n  TKeyboardEvent\n>({ props, refresh, store, ...setters }: GetPropGettersOptions<TItem>) {\n  const getEnvironmentProps: GetEnvironmentProps = (getterProps) => {\n    return {\n      // On touch devices, we do not rely on the native `blur` event of the\n      // input to close the panel, but rather on a custom `touchstart` event\n      // outside of the autocomplete elements.\n      // This ensures a working experience on mobile because we blur the input\n      // on touch devices when the user starts scrolling (`touchmove`).\n      onTouchStart(event) {\n        if (\n          store.getState().isOpen === false ||\n          event.target === getterProps.inputElement\n        ) {\n          return;\n        }\n\n        // @TODO: support cases where there are multiple Autocomplete instances.\n        // Right now, a second instance makes this computation return false.\n        const isTargetWithinAutocomplete = [\n          getterProps.formElement,\n          getterProps.panelElement,\n        ].some((contextNode) => {\n          return (\n            isOrContainsNode(contextNode, event.target as Node) ||\n            isOrContainsNode(\n              contextNode,\n              props.environment.document.activeElement!\n            )\n          );\n        });\n\n        if (isTargetWithinAutocomplete === false) {\n          store.dispatch('blur', null);\n        }\n      },\n      // When scrolling on touch devices (mobiles, tablets, etc.), we want to\n      // mimic the native platform behavior where the input is blurred to\n      // hide the virtual keyboard. This gives more vertical space to\n      // discover all the suggestions showing up in the panel.\n      onTouchMove(event: TouchEvent) {\n        if (\n          store.getState().isOpen === false ||\n          getterProps.inputElement !==\n            props.environment.document.activeElement ||\n          event.target === getterProps.inputElement\n        ) {\n          return;\n        }\n\n        getterProps.inputElement.blur();\n      },\n    };\n  };\n\n  const getRootProps: GetRootProps = (rest) => {\n    return {\n      role: 'combobox',\n      'aria-expanded': store.getState().isOpen,\n      'aria-haspopup': 'listbox',\n      'aria-owns': store.getState().isOpen ? `${props.id}-list` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getFormProps: GetFormProps<TEvent> = (providedProps) => {\n    const { inputElement, ...rest } = providedProps;\n\n    return {\n      action: '',\n      noValidate: true,\n      role: 'search',\n      onSubmit: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onSubmit({\n          event,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        });\n\n        store.dispatch('submit', null);\n        providedProps.inputElement?.blur();\n      },\n      onReset: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onReset({\n          event,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        });\n\n        store.dispatch('reset', null);\n        providedProps.inputElement?.focus();\n      },\n      ...rest,\n    };\n  };\n\n  const getInputProps: GetInputProps<TEvent, TMouseEvent, TKeyboardEvent> = (\n    providedProps\n  ) => {\n    function onFocus(event: TEvent) {\n      // We want to trigger a query when `openOnFocus` is true\n      // because the panel should open with the current query.\n      if (props.openOnFocus || store.getState().query.length > 0) {\n        onInput({\n          event,\n          props,\n          query: store.getState().completion || store.getState().query,\n          refresh,\n          store,\n          ...setters,\n        });\n      }\n\n      store.dispatch('focus', null);\n    }\n\n    const isTouchDevice = 'ontouchstart' in props.environment;\n    const { inputElement, maxLength = 512, ...rest } = providedProps || {};\n    const selectedItem = getSelectedItem(store.getState());\n\n    return {\n      'aria-autocomplete': 'both',\n      'aria-activedescendant':\n        store.getState().isOpen && store.getState().selectedItemId !== null\n          ? `${props.id}-item-${store.getState().selectedItemId}`\n          : undefined,\n      'aria-controls': store.getState().isOpen ? `${props.id}-list` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      value: store.getState().completion || store.getState().query,\n      id: `${props.id}-input`,\n      autoComplete: 'off',\n      autoCorrect: 'off',\n      autoCapitalize: 'off',\n      enterKeyHint: selectedItem?.itemUrl ? 'go' : 'search',\n      spellCheck: 'false',\n      autoFocus: props.autoFocus,\n      placeholder: props.placeholder,\n      maxLength,\n      type: 'search',\n      onChange: (event) => {\n        onInput({\n          event,\n          props,\n          query: (((event as unknown) as Event)\n            .currentTarget as HTMLInputElement).value.slice(0, maxLength),\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onKeyDown: (event) => {\n        onKeyDown({\n          event: (event as unknown) as KeyboardEvent,\n          props,\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onFocus,\n      onBlur: () => {\n        // We do rely on the `blur` event on touch devices.\n        // See explanation in `onTouchStart`.\n        if (!isTouchDevice) {\n          store.dispatch('blur', null);\n        }\n      },\n      onClick: (event) => {\n        // When the panel is closed and you click on the input while\n        // the input is focused, the `onFocus` event is not triggered\n        // (default browser behavior).\n        // In an autocomplete context, it makes sense to open the panel in this\n        // case.\n        // We mimic this event by catching the `onClick` event which\n        // triggers the `onFocus` for the panel to open.\n        if (\n          providedProps.inputElement ===\n            props.environment.document.activeElement &&\n          !store.getState().isOpen\n        ) {\n          onFocus((event as unknown) as TEvent);\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getLabelProps: GetLabelProps = (rest) => {\n    return {\n      htmlFor: `${props.id}-input`,\n      id: `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getListProps: GetListProps = (rest) => {\n    return {\n      role: 'listbox',\n      'aria-labelledby': `${props.id}-label`,\n      id: `${props.id}-list`,\n      ...rest,\n    };\n  };\n\n  const getPanelProps: GetPanelProps<TMouseEvent> = (rest) => {\n    return {\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the panel so\n        // that the blur event is not triggered, otherwise it closes the\n        // panel.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onMouseLeave() {\n        store.dispatch('mouseleave', null);\n      },\n      ...rest,\n    };\n  };\n\n  const getItemProps: GetItemProps<any, TMouseEvent> = (providedProps) => {\n    const { item, source, ...rest } = providedProps;\n\n    return {\n      id: `${props.id}-item-${item.__autocomplete_id}`,\n      role: 'option',\n      'aria-selected':\n        store.getState().selectedItemId === item.__autocomplete_id,\n      onMouseMove(event) {\n        if (item.__autocomplete_id === store.getState().selectedItemId) {\n          return;\n        }\n\n        store.dispatch('mousemove', item.__autocomplete_id);\n\n        const highlightedItem = getSelectedItem(store.getState());\n\n        if (store.getState().selectedItemId !== null && highlightedItem) {\n          const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n          source.onHighlight({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        }\n      },\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the item so it\n        // can remain with the current `activeElement`.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onClick(event) {\n        const itemInputValue = source.getItemInputValue({\n          item,\n          state: store.getState(),\n        });\n        const itemUrl = source.getItemUrl({\n          item,\n          state: store.getState(),\n        });\n\n        // If `getItemUrl` is provided, it means that the suggestion\n        // is a link, not plain text that aims at updating the query.\n        // We can therefore skip the state change because it will update\n        // the `selectedItemId`, resulting in a UI flash, especially\n        // noticeable on mobile.\n        const runPreCommand = itemUrl\n          ? Promise.resolve()\n          : onInput({\n              event,\n              nextState: { isOpen: false },\n              props,\n              query: itemInputValue,\n              refresh,\n              store,\n              ...setters,\n            });\n\n        runPreCommand.then(() => {\n          source.onSelect({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        });\n      },\n      ...rest,\n    };\n  };\n\n  return {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getPanelProps,\n    getListProps,\n    getItemProps,\n  };\n}\n","import { onInput } from './onInput';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getSelectedItem } from './utils';\n\ninterface OnKeyDownOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: KeyboardEvent;\n  props: InternalAutocompleteOptions<TItem>;\n  store: AutocompleteStore<TItem>;\n}\n\nexport function onKeyDown<TItem extends BaseItem>({\n  event,\n  props,\n  refresh,\n  store,\n  ...setters\n}: OnKeyDownOptions<TItem>): void {\n  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n    // Default browser behavior changes the caret placement on ArrowUp and\n    // Arrow down.\n    event.preventDefault();\n\n    store.dispatch(event.key, null);\n\n    const nodeItem = props.environment.document.getElementById(\n      `${props.id}-item-${store.getState().selectedItemId}`\n    );\n\n    if (nodeItem) {\n      if ((nodeItem as any).scrollIntoViewIfNeeded) {\n        (nodeItem as any).scrollIntoViewIfNeeded(false);\n      } else {\n        nodeItem.scrollIntoView(false);\n      }\n    }\n\n    const highlightedItem = getSelectedItem(store.getState());\n\n    if (store.getState().selectedItemId !== null && highlightedItem) {\n      const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n      source.onHighlight({\n        event,\n        item,\n        itemInputValue,\n        itemUrl,\n        refresh,\n        source,\n        state: store.getState(),\n        ...setters,\n      });\n    }\n  } else if (event.key === 'Escape') {\n    // This prevents the default browser behavior on `input[type=\"search\"]`\n    // from removing the query right away because we first want to close the\n    // panel.\n    event.preventDefault();\n\n    store.dispatch(event.key, null);\n  } else if (event.key === 'Enter') {\n    // No item is selected, so we let the browser handle the native `onSubmit`\n    // form event.\n    if (\n      store.getState().selectedItemId === null ||\n      store\n        .getState()\n        .collections.every((collection) => collection.items.length === 0)\n    ) {\n      return;\n    }\n\n    // This prevents the `onSubmit` event to be sent because an item is\n    // highlighted.\n    event.preventDefault();\n\n    const { item, itemInputValue, itemUrl, source } = getSelectedItem(\n      store.getState()\n    )!;\n\n    if (event.metaKey || event.ctrlKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewTab({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.shiftKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewWindow({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.altKey) {\n      // Keep native browser behavior\n    } else {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigate({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n\n        return;\n      }\n\n      onInput({\n        event,\n        nextState: { isOpen: false },\n        props,\n        query: itemInputValue,\n        refresh,\n        store,\n        ...setters,\n      }).then(() => {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      });\n    }\n  }\n}\n","import { AutocompleteState, BaseItem } from './types';\nimport { getSelectedItem } from './utils';\n\ninterface GetCompletionProps<TItem extends BaseItem> {\n  state: AutocompleteState<TItem>;\n}\n\nexport function getCompletion<TItem extends BaseItem>({\n  state,\n}: GetCompletionProps<TItem>): string | null {\n  if (state.isOpen === false || state.selectedItemId === null) {\n    return null;\n  }\n\n  const { itemInputValue } = getSelectedItem(state)!;\n\n  return itemInputValue || null;\n}\n","import { invariant } from '@algolia/autocomplete-shared';\n\nimport { getCompletion } from './getCompletion';\nimport { Reducer } from './types';\nimport { getItemsCount, getNextSelectedItemId } from './utils';\n\nexport const stateReducer: Reducer = (state, action) => {\n  switch (action.type) {\n    case 'setSelectedItemId': {\n      return {\n        ...state,\n        selectedItemId: action.payload,\n      };\n    }\n\n    case 'setQuery': {\n      return {\n        ...state,\n        query: action.payload,\n        completion: null,\n      };\n    }\n\n    case 'setCollections': {\n      return {\n        ...state,\n        collections: action.payload,\n      };\n    }\n\n    case 'setIsOpen': {\n      return {\n        ...state,\n        isOpen: action.payload,\n      };\n    }\n\n    case 'setStatus': {\n      return {\n        ...state,\n        status: action.payload,\n      };\n    }\n\n    case 'setContext': {\n      return {\n        ...state,\n        context: {\n          ...state.context,\n          ...action.payload,\n        },\n      };\n    }\n\n    case 'ArrowDown': {\n      const nextState = {\n        ...state,\n        selectedItemId: getNextSelectedItemId(\n          1,\n          state.selectedItemId,\n          getItemsCount(state),\n          action.props.defaultSelectedItemId\n        ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'ArrowUp': {\n      const nextState = {\n        ...state,\n        selectedItemId: getNextSelectedItemId(\n          -1,\n          state.selectedItemId,\n          getItemsCount(state),\n          action.props.defaultSelectedItemId\n        ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'Escape': {\n      if (state.isOpen) {\n        return {\n          ...state,\n          isOpen: false,\n          completion: null,\n        };\n      }\n\n      return {\n        ...state,\n        query: '',\n        status: 'idle',\n        collections: [],\n      };\n    }\n\n    case 'submit': {\n      return {\n        ...state,\n        selectedItemId: null,\n        isOpen: false,\n        status: 'idle',\n      };\n    }\n\n    case 'reset': {\n      return {\n        ...state,\n        selectedItemId:\n          // Since we open the panel on reset when openOnFocus=true\n          // we need to restore the highlighted index to the defaultSelectedItemId. (DocSearch use-case)\n\n          // Since we close the panel when openOnFocus=false\n          // we lose track of the highlighted index. (Query-suggestions use-case)\n          action.props.openOnFocus === true\n            ? action.props.defaultSelectedItemId\n            : null,\n        status: 'idle',\n        query: '',\n      };\n    }\n\n    case 'focus': {\n      return {\n        ...state,\n        selectedItemId: action.props.defaultSelectedItemId,\n        isOpen: action.props.openOnFocus || state.query.length > 0,\n      };\n    }\n\n    case 'blur': {\n      if (action.props.debug) {\n        return state;\n      }\n\n      return {\n        ...state,\n        isOpen: false,\n        selectedItemId: null,\n      };\n    }\n\n    case 'mousemove': {\n      return {\n        ...state,\n        selectedItemId: action.payload,\n      };\n    }\n\n    case 'mouseleave': {\n      return {\n        ...state,\n        selectedItemId: action.props.defaultSelectedItemId,\n      };\n    }\n\n    default:\n      invariant(\n        false,\n        `The reducer action ${JSON.stringify(action.type)} is not supported.`\n      );\n\n      return state;\n  }\n};\n","import { checkOptions } from './checkOptions';\nimport { createStore } from './createStore';\nimport { getAutocompleteSetters } from './getAutocompleteSetters';\nimport { getDefaultProps } from './getDefaultProps';\nimport { getPropGetters } from './getPropGetters';\nimport { onInput } from './onInput';\nimport { stateReducer } from './stateReducer';\nimport {\n  AutocompleteApi,\n  AutocompleteOptions,\n  BaseItem,\n  AutocompleteSubscribers,\n} from './types';\n\nexport function createAutocomplete<\n  TItem extends BaseItem,\n  TEvent = Event,\n  TMouseEvent = MouseEvent,\n  TKeyboardEvent = KeyboardEvent\n>(\n  options: AutocompleteOptions<TItem>\n): AutocompleteApi<TItem, TEvent, TMouseEvent, TKeyboardEvent> {\n  checkOptions(options);\n\n  const subscribers: AutocompleteSubscribers<TItem> = [];\n  const props = getDefaultProps(options, subscribers);\n  const store = createStore(stateReducer, props);\n\n  const setters = getAutocompleteSetters({ store });\n  const propGetters = getPropGetters<\n    TItem,\n    TEvent,\n    TMouseEvent,\n    TKeyboardEvent\n  >({ props, refresh, store, ...setters });\n\n  function refresh() {\n    return onInput({\n      event: new Event('input'),\n      nextState: { isOpen: store.getState().isOpen },\n      props,\n      query: store.getState().query,\n      refresh,\n      store,\n      ...setters,\n    });\n  }\n\n  props.plugins.forEach((plugin) =>\n    plugin.subscribe?.({\n      ...setters,\n      onSelect(fn) {\n        subscribers.push({ onSelect: fn });\n      },\n      onHighlight(fn) {\n        subscribers.push({ onHighlight: fn });\n      },\n    })\n  );\n\n  return {\n    refresh,\n    ...propGetters,\n    ...setters,\n  };\n}\n","import {\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n  Reducer,\n} from './types';\n\nexport function createStore<TItem extends BaseItem>(\n  reducer: Reducer,\n  props: InternalAutocompleteOptions<TItem>\n): AutocompleteStore<TItem> {\n  let state = props.initialState;\n\n  return {\n    getState() {\n      return state;\n    },\n    dispatch(action, payload) {\n      const prevState = { ...state };\n      state = reducer(state, {\n        type: action,\n        props,\n        payload,\n      });\n\n      props.onStateChange({ state, prevState });\n    },\n  };\n}\n","import {\n  AutocompleteApi,\n  AutocompleteCollection,\n  AutocompleteStore,\n  BaseItem,\n} from './types';\nimport { flatten } from './utils';\n\ninterface GetAutocompleteSettersOptions<TItem extends BaseItem> {\n  store: AutocompleteStore<TItem>;\n}\n\nexport function getAutocompleteSetters<TItem extends BaseItem>({\n  store,\n}: GetAutocompleteSettersOptions<TItem>) {\n  const setSelectedItemId: AutocompleteApi<TItem>['setSelectedItemId'] = (\n    value\n  ) => {\n    store.dispatch('setSelectedItemId', value);\n  };\n\n  const setQuery: AutocompleteApi<TItem>['setQuery'] = (value) => {\n    store.dispatch('setQuery', value);\n  };\n\n  const setCollections: AutocompleteApi<TItem>['setCollections'] = (\n    rawValue\n  ) => {\n    let baseItemId = 0;\n    const value = rawValue.map<AutocompleteCollection<TItem>>((collection) => ({\n      ...collection,\n      // We flatten the stored items to support calling `getAlgoliaHits`\n      // from the source itself.\n      items: flatten(collection.items as any).map((item: any) => ({\n        ...item,\n        __autocomplete_id: baseItemId++,\n      })),\n    }));\n\n    store.dispatch('setCollections', value);\n  };\n\n  const setIsOpen: AutocompleteApi<TItem>['setIsOpen'] = (value) => {\n    store.dispatch('setIsOpen', value);\n  };\n\n  const setStatus: AutocompleteApi<TItem>['setStatus'] = (value) => {\n    store.dispatch('setStatus', value);\n  };\n\n  const setContext: AutocompleteApi<TItem>['setContext'] = (value) => {\n    store.dispatch('setContext', value);\n  };\n\n  return {\n    setSelectedItemId,\n    setQuery,\n    setCollections,\n    setIsOpen,\n    setStatus,\n    setContext,\n  };\n}\n","export const version = '1.0.0-alpha.38';\n"],"names":["flatten","values","reduce","a","b","concat","autocompleteId","getItemsCount","state","collections","length","sum","collection","items","getNextSelectedItemId","moveAmount","baseIndex","itemCount","defaultSelectedItemId","numericIndex","noop","getSelectedItem","collectionIndex","map","acc","collectionsCount","index","nextValue","push","current","selectedItemId","getCollectionFromSelectedItemId","item","isOffsetFound","counter","previousItemsOffset","currentCollection","getRelativeSelectedItemId","source","itemInputValue","getItemInputValue","itemUrl","getItemUrl","isOrContainsNode","parent","child","contains","getDefaultProps","props","pluginSubscribers","environment","window","plugins","debug","openOnFocus","placeholder","autoFocus","stallThreshold","shouldPanelShow","id","initialState","query","completion","isOpen","status","context","onStateChange","params","forEach","x","_x$onStateChange","onSubmit","_x$onSubmit","onReset","_x$onReset","getSources","Promise","all","plugin","filter","Boolean","resolve","then","sources","Array","isArray","JSON","stringify","maybeSource","normalizedSource","onSelect","setIsOpen","onHighlight","getNormalizedSources","nested","_x$onSelect","_x$onHighlight","navigator","navigate","location","assign","navigateNewTab","windowReference","open","focus","navigateNewWindow","lastStalledId","onInput","event","nextState","refresh","store","setters","getState","clearTimeout","setCollections","setQuery","setSelectedItemId","setStatus","setTimeout","getItems","highlightedItem","catch","error","finally","getPropGetters","getEnvironmentProps","getterProps","onTouchStart","target","inputElement","formElement","panelElement","some","contextNode","document","activeElement","dispatch","onTouchMove","blur","getRootProps","rest","role","undefined","getFormProps","providedProps","action","noValidate","preventDefault","getLabelProps","htmlFor","getInputProps","onFocus","isTouchDevice","maxLength","selectedItem","value","autoComplete","autoCorrect","autoCapitalize","enterKeyHint","spellCheck","type","onChange","currentTarget","slice","onKeyDown","key","nodeItem","getElementById","scrollIntoViewIfNeeded","scrollIntoView","every","metaKey","ctrlKey","shiftKey","altKey","onBlur","onClick","getPanelProps","onMouseDown","onMouseLeave","getListProps","getItemProps","__autocomplete_id","onMouseMove","getCompletion","stateReducer","payload","options","subscribers","reducer","prevState","createStore","rawValue","baseItemId","setContext","getAutocompleteSetters","propGetters","Event","subscribe","_plugin$subscribe","fn"],"mappings":"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"}